/*
 * Messages for KeepKey Communication
 *
 * @trezor_author	Marek Palatinus <slush@satoshilabs.com>
 * @trezor_version	1.2
 * @keepkey_author 	Darin Stanchfield <darin@keepkey.com>
 * @keepkey_version	1.0
 */

//NOTE
// The tags in the Javadoc-like comments are used by the ui. They are code. Changing them wrongly will break the
// UI build. See https://github.com/keepkey/device-protocol-state-dsl for details.

// Sugar for easier handling in Java
option java_package = "com.keepkey.device-protocol";
option java_outer_classname = "KeepKeyMessage";

import "types.proto";

/**
 * Mapping between KeepKey wire identifier (uint) and a protobuf message
 */
enum MessageType {
	MessageType_Initialize = 0 [(wire_in) = true];
	MessageType_Ping = 1 [(wire_in) = true];
	MessageType_Success = 2 [(wire_out) = true];
	MessageType_Failure = 3 [(wire_out) = true];
	MessageType_ChangePin = 4 [(wire_in) = true];
	MessageType_WipeDevice = 5 [(wire_in) = true];
	MessageType_FirmwareErase = 6 [(wire_in) = true];
	MessageType_FirmwareUpload = 7 [(wire_in) = true];
	MessageType_GetEntropy = 9 [(wire_in) = true];
	MessageType_Entropy = 10 [(wire_out) = true];
	MessageType_GetPublicKey = 11 [(wire_in) = true];
	MessageType_PublicKey = 12 [(wire_out) = true];
	MessageType_LoadDevice = 13 [(wire_in) = true];
	MessageType_ResetDevice = 14 [(wire_in) = true];
	MessageType_SignTx = 15 [(wire_in) = true];
	MessageType_SimpleSignTx = 16 [(wire_in) = true];
	MessageType_Features = 17 [(wire_out) = true];
	MessageType_PinMatrixRequest = 18 [(wire_out) = true];
	MessageType_PinMatrixAck = 19 [(wire_in) = true];
	MessageType_Cancel = 20 [(wire_in) = true];
	MessageType_TxRequest = 21 [(wire_out) = true];
	MessageType_TxAck = 22 [(wire_in) = true];
	MessageType_CipherKeyValue = 23 [(wire_in) = true];
	MessageType_ClearSession = 24 [(wire_in) = true];
	MessageType_ApplySettings = 25 [(wire_in) = true];
	MessageType_ButtonRequest = 26 [(wire_out) = true];
	MessageType_ButtonAck = 27 [(wire_in) = true];
	MessageType_GetAddress = 29 [(wire_in) = true];
	MessageType_Address = 30 [(wire_out) = true];
	MessageType_EntropyRequest = 35 [(wire_out) = true];
	MessageType_EntropyAck = 36 [(wire_in) = true];
	MessageType_SignMessage = 38 [(wire_in) = true];
	MessageType_VerifyMessage = 39 [(wire_in) = true];
	MessageType_MessageSignature = 40 [(wire_out) = true];
	MessageType_PassphraseRequest = 41 [(wire_out) = true];
	MessageType_PassphraseAck = 42 [(wire_in) = true];
	MessageType_EstimateTxSize = 43 [(wire_in) = true];
	MessageType_TxSize = 44 [(wire_out) = true];
	MessageType_RecoveryDevice = 45 [(wire_in) = true];
	MessageType_WordRequest = 46 [(wire_out) = true];
	MessageType_WordAck = 47 [(wire_in) = true];
	MessageType_CipheredKeyValue = 48 [(wire_out) = true];
	MessageType_EncryptMessage = 49 [(wire_in) = true];
	MessageType_EncryptedMessage = 50 [(wire_out) = true];
	MessageType_DecryptMessage = 51 [(wire_in) = true];
	MessageType_DecryptedMessage = 52 [(wire_out) = true];
	MessageType_SignIdentity = 53 [(wire_in) = true];
	MessageType_SignedIdentity = 54 [(wire_out) = true];
	MessageType_GetFeatures = 55 [(wire_in) = true];
 	MessageType_CharacterRequest = 80 [(wire_out) = true];
 	MessageType_CharacterAck = 81 [(wire_in) = true];
	MessageType_DebugLinkDecision = 100 [(wire_debug_in) = true];
	MessageType_DebugLinkGetState = 101 [(wire_debug_in) = true];
	MessageType_DebugLinkState = 102 [(wire_debug_out) = true];
	MessageType_DebugLinkStop = 103 [(wire_debug_in) = true];
	MessageType_DebugLinkLog = 104 [(wire_debug_out) = true];
	MessageType_DebugLinkFillConfig = 105 [(wire_debug_out) = true];
}

////////////////////
// Basic messages //
////////////////////

/**
 * Reset device to default state and ask for device details
 *
 * @validMode running
 * @sender host
 * @messageType request
 * @resolve Features
 */
message Initialize {
}

/**
 * Ask for device details (no device reset)
 *
 * @validMode running
 * @sender host
 * @messageType request
 * @resolve Features
 */
message GetFeatures {
}

/**
 * Report information about the device
 *
 * @validMode running
 * @sender device
 * @messageType response
 * @prev Initialize
 * @prev GetFeatures
 */
message Features {
	optional string vendor = 1;			// name of the manufacturer, e.g. "bitcointrezor.com"
	optional uint32 major_version = 2;		// major version of the device, e.g. 1
	optional uint32 minor_version = 3;		// minor version of the device, e.g. 0
	optional uint32 patch_version = 4;		// patch version of the device, e.g. 0
	optional bool bootloader_mode = 5;		// is device in bootloader mode?
	optional string device_id = 6;			// device's unique identifier
	optional bool pin_protection = 7;		// is device protected by PIN?
	optional bool passphrase_protection = 8;	// is node/mnemonic encrypted using passphrase?
	optional string language = 9;			// device language
	optional string label = 10;			// device description label
	repeated CoinType coins = 11;			// supported coins
	optional bool initialized = 12;			// does device contain seed?
	optional bytes revision = 13;			// SCM revision of firmware
	optional bytes bootloader_hash = 14;		// hash of the bootloader
	optional bool imported = 15;			// was storage imported from an external source?
	optional bool pin_cached = 16;			// is PIN already cached in session?
	optional bool passphrase_cached = 17;		// is passphrase already cached in session?
}

/**
 * Clear session (removes cached PIN, passphrase, etc).
 *
 * @validMode running
 * @sender host
 * @messageType request
 * @resolve Success
 */
message ClearSession {
}

/**
 * Change language and/or label of the device
 *
 * @validMode running
 * @sender host
 * @messageType request
 * @resolve Success
 * @reject Failure
 * @next ButtonRequest
 * @next PinMatrixRequest
 */
message ApplySettings {
	optional string language = 1;
	optional string label = 2;
	optional bool use_passphrase = 3;
}

/**
 * Start workflow for setting/changing/removing the PIN
 *
 * @validMode running
 * @sender host
 * @messageType request
 * @resolve Success
 * @reject Failure
 * @next ButtonRequest
 * @next PinMatrixRequest
 */
message ChangePin {
	optional bool remove = 1;	// is PIN removal requested?
}

/**
 * Test if the device is alive, device sends back the message in Success response
 *
 * @validMode running
 * @sender host
 * @messageType request
 * @resolve Success
 */
message Ping {
	optional string message = 1;			// message to send back in Success message
	optional bool button_protection = 2;		// ask for button press
	optional bool pin_protection = 3;		// ask for PIN if set in device
	optional bool passphrase_protection = 4;	// ask for passphrase if set in device
}

/**
 * Success of the previous request
 *
 * @validMode running
 * @sender device
 * @messageType response
 */
message Success {
	optional string message = 1;	// human readable description of action or request-specific payload
}

/**
 * Failure of the previous request
  *
  * @validMode running
  * @sender device
  * @messageType response
 */
message Failure {
	optional FailureType code = 1;	// computer-readable definition of the error state
	optional string message = 2;	// human-readable message of the error state
}

/**
 * Device is waiting for HW button press.
 *
 * @validMode running
 * @sender device
 * @messageType request
 * @next ButtonAck
 * @next Cancel
 */
message ButtonRequest {
	optional ButtonRequestType code = 1;
	optional string data = 2;
}

/**
 * Acknowledge button request
 *
 * @validMode running
 * @sender host
 * @messageType response
 * @prev ButtonRequest
 */
message ButtonAck {
}

/**
 * Prompt for PIN
 *
 * @validMode running
 * @sender device
 * @messageType request
 * @next PinMatrixAck
 * @next Cancel
 * @userInteractionRequired
 */
message PinMatrixRequest {
	optional PinMatrixRequestType type = 1;
}

/**
 * Send encoded PIN
 *
 * @validMode running
 * @sender host
 * @messageType response
 * @prev PinMatrixRequest
 */
message PinMatrixAck {
	required string pin = 1;		// matrix encoded PIN entered by user
}

/**
 * Abort last operation that required user interaction
 *
 * @validMode running
 * @sender host
 * @messageType request
 * @prev ButtonRequest
 * @prev PinMatrixRequest
 * @prev PassphraseRequest
 */
message Cancel {
}

/**
 * Prompt for passphrase
 *
 * @validMode running
 * @sender device
 * @messageType request
 * @next PassphraseAck
 * @next Cancel
 * @userInteractionRequired
 */
message PassphraseRequest {
}

/**
 * Send passphrase
 *
 * @validMode running
 * @sender host
 * @messageType response
 * @prev PassphraseRequest
 */
message PassphraseAck {
	required string passphrase = 1;
}

/**
 * Get random data generated by device RNG.
 *
 * @validMode running
 * @sender host
 * @messageType request
 * @next ButtonRequest
 * @resolve Entropy
 * @reject Failure
 */
message GetEntropy {
	required uint32 size = 1;		// size of requested entropy
}

/**
 * Random data generated by device RNG
 *
 * @validMode running
 * @sender device
 * @messageType response
 * @prev GetEntropy
 */
message Entropy {
	required bytes entropy = 1;		// stream of random generated bytes
}

/**
 * Get public key corresponding to address_n path
 *
 * @validMode running
 * @sender host
 * @messageType request
 * @next PassphraseRequest
 * @next PinMatrixRequest
 * @resolve PublicKey
 * @reject Failure
 */
message GetPublicKey {
	repeated uint32 address_n = 1;		// BIP-32 path to derive the key from master node
	optional string ecdsa_curve_name = 2;		// ECDSA curve name to use
}

/**
 * Contains public key derived from device private seed
 *
 * @validMode running
 * @sender device
 * @messageType response
 * @prev GetPublicKey
 */
message PublicKey {
	required HDNodeType node = 1;		// BIP32 public node
	optional string xpub = 2;		// serialized form of public node
}

/**
 * Get address corresponding to address_n path
 *
 * @validMode running
 * @sender host
 * @messageType request
 * @next PinMatrixRequest
 * @next PassphraseRequest
 * @resolve Address
 * @reject Failure
 */
message GetAddress {
	repeated uint32 address_n = 1;			// BIP-32 path to derive the key from master node
	optional string coin_name = 2 [default='Bitcoin'];
	optional bool show_display = 3;
	optional MultisigRedeemScriptType multisig = 4;	// Filled if we are showing a multisig address
}

/**
 * Address derived from private seed
 *
 * @validMode running
 * @sender device
 * @messageType response
 * @prev GetAddress
 */
message Address {
	required string address = 1;		// Coin address in Base58 encoding
}

/**
 * Wipe all sensitive data and settings
 *
 * @validMode running
 * @sender host
 * @messageType request
 * @next ButtonRequest
 * @resolve Success
 */
message WipeDevice {
}

/**
 * Load seed and related internal settings
 *
 * @validMode running
 * @sender host
 * @messageType request
 * @next ButtonRequest
 * @next PassphraseRequest
 * @resolve Success
 * @reject Failure
 */
message LoadDevice {
	optional string mnemonic = 1;				// seed encoded as BIP-39 mnemonic (12, 18 or 24 words)
	optional HDNodeType node = 2;				// BIP-32 node
	optional string pin = 3;				// set PIN protection
	optional bool passphrase_protection = 4;		// enable master node encryption using passphrase
	optional string language = 5 [default='english'];	// device language
	optional string label = 6;				// device label
	optional bool skip_checksum = 7;			// do not test mnemonic for valid BIP-39 checksum
}

/**
 * Start initialization involving user interaction
 *
 * @validMode running
 * @sender host
 * @messageType request
 * @next EntropyRequest
 * @next PinMatrixRequest
 * @next ButtonRequest
 * @next PassphraseRequest
 * @resolve Success
 * @reject Failure
 * @userInteractionRequired
 */
message ResetDevice {
	optional bool display_random = 1;			// display entropy generated by the device before asking for additional entropy
	optional uint32 strength = 2 [default=256];		// strength of seed in bits
	optional bool passphrase_protection = 3;		// enable master node encryption using passphrase
	optional bool pin_protection = 4;			// enable PIN protection
	optional string language = 5 [default='english'];	// device language
	optional string label = 6;				// device label
}

/**
 * Get entropy from the host
 *
 * @validMode running
 * @sender device
 * @messageType request
 * @prev ResetDevice
 * @next EntropyAck
 */
message EntropyRequest {
}

/**
 * Entropy from the host
 *
 * @validMode running
 * @sender host
 * @messageType response
 * @prev EntropyRequest
 */
message EntropyAck {
	optional bytes entropy = 1;				// 256 bits (32 bytes) of random data
}

/**
 * Start recovery workflow
 *
 * @validMode running
 * @sender host
 * @messageType request
 * @next WordRequest
 * @next PinMatrixRequest
 * @resolve Success
 * @reject Failure
 * @userInteractionRequired
 */
message RecoveryDevice {
	optional uint32 word_count = 1;				// number of words in BIP-39 mnemonic
	optional bool passphrase_protection = 2;		// enable master node encryption using passphrase
	optional bool pin_protection = 3;			// enable PIN protection
	optional string language = 4 [default='english'];	// device language
	optional string label = 5;				// device label
	optional bool enforce_wordlist = 6;			// enforce BIP-39 wordlist during the process
	optional bool use_character_cipher = 7;			// an optional way to input recovery sentence by character using a cipher
}

/**
 * Get requested mnemonic from the user
 *
 * @validMode running
 * @sender device
 * @messageType request
 * @prev RecoveryDevice
 * @prev WordAck
 */
message WordRequest {
}

/**
 * Send a mnemonic
 *
 * @validMode running
 * @sender host
 * @messageType response
 * @prev WordRequest
 * @next WordRequest
 */
message WordAck {
	required string word = 1;				// one word of mnemonic on asked position
}

/**
 * Get a character from the mnemonic using a cipher
 *
 * @validMode running
 * @sender device
 * @messageType request
 * @prev RecoveryDevice
 * @prev CharacterAck
 * @next CharacterAck
 */
message CharacterRequest {
	required uint32 word_pos = 1;			// word position in BIP-39 mnemonic
	required uint32 character_pos = 2;		// character position
}

/**
 * Send a character from the mnemonic using cipher
 *
 * @validMode running
 * @sender host
 * @messageType response
 * @prev CharacterRequest
 * @next CharacterRequest
 */
message CharacterAck {
	optional string character = 1;				// one character of mnemonic using cipher
	optional bool delete = 2;				// request to delete previous character from ciphered mnemonic
	optional bool done = 3;					// marks there are no more characters left for ciphered mnemonic
}

//////////////////////////////
// Message signing messages //
//////////////////////////////

/**
 * Sign a message
 *
 * @validMode running
 * @sender host
 * @messageType request
 * @resolve MessageSignature
 * @reject Failure
 */
message SignMessage {
	repeated uint32 address_n = 1;				// BIP-32 path to derive the key from master node
	required bytes message = 2;				// message to be signed
	optional string coin_name = 3 [default='Bitcoin'];	// coin to use for signing
}

/**
 * Verify a message
 *
 * @validMode running
 * @sender host
 * @messageType request
 * @resolve Success
 * @reject Failure
 */
message VerifyMessage {
	optional string address = 1;				// address to verify
	optional bytes signature = 2;				// signature to verify
	optional bytes message = 3;				// message to verify
}

/**
 * Signed message
 *
 * @validMode running
 * @sender device
 * @messageType response
 * @prev SignMessage
 */
message MessageSignature {
	optional string address = 1;				// address used to sign the message
	optional bytes signature = 2;				// signature of the message
}

///////////////////////////
// Encryption/decryption //
///////////////////////////

/**
 * Encrypt a message
 *
 * @validMode running
 * @sender host
 * @messageType request
 * @resolve EncryptedMessage
 * @reject Failure
 */
message EncryptMessage {
	optional bytes pubkey = 1;				// public key
	optional bytes message = 2;				// message to encrypt
	optional bool display_only = 3;				// show just on display? (don't send back via wire)
	repeated uint32 address_n = 4;				// BIP-32 path to derive the signing key from master node
	optional string coin_name = 5 [default='Bitcoin'];	// coin to use for signing
}

/**
 * Encrypted message
 *
 * @validMode running
 * @sender device
 * @messageType response
 * @prev EncryptMessage
 */
message EncryptedMessage {
	optional bytes nonce = 1;				// nonce used during encryption
	optional bytes message = 2;				// encrypted message
	optional bytes hmac = 3;				// message hmac
}

/**
 * Decrypt a message
 *
 * @validMode running
 * @sender host
 * @messageType request
 * @resolve Success
 * @reject Failure
 */
message DecryptMessage {
	repeated uint32 address_n = 1;				// BIP-32 path to derive the decryption key from master node
	optional bytes nonce = 2;				// nonce used during encryption
	optional bytes message = 3;				// message to decrypt
	optional bytes hmac = 4;				// message hmac
}

/**
 * Decrypted message
 *
 * @validMode running
 * @sender device
 * @messageType response
 * @prev DecryptedMessage
 */
message DecryptedMessage {
	optional bytes message = 1;				// decrypted message
	optional string address = 2;				// address used to sign the message (if used)
}

/**
 * Encrypt or decrypt value with given key
 *
 * @validMode running
 * @sender host
 * @messageType request
 * @resolve CipheredKeyValue
 * @reject Failure
 */
message CipherKeyValue {
	repeated uint32 address_n = 1;		// BIP-32 path to derive the key from master node
	optional string key = 2;		// key component of key:value
	optional bytes value = 3;		// value component of key:value
	optional bool encrypt = 4;		// are we encrypting (True) or decrypting (False)?
	optional bool ask_on_encrypt = 5;	// should we ask on encrypt operation?
	optional bool ask_on_decrypt = 6;	// should we ask on decrypt operation?
	optional bytes iv = 7;			// initialization vector (will be computed if not set)
}

/**
 * Ciphered/deciphered value
 *
 * @validMode running
 * @sender device
 * @messageType response
 * @prev CipherKeyValue
 */
message CipheredKeyValue {
	optional bytes value = 1;		// ciphered/deciphered value
}

//////////////////////////////////
// Transaction signing messages //
//////////////////////////////////

/**
 * Estimated size of a transaction
 * This behaves exactly like SignTx, which means that it can ask using TxRequest
 * This call is non-blocking (except possible PassphraseRequest to unlock the seed)
 *
 * @validMode running
 * @sender host
 * @messageType request
 * @resolve TxSize
 * @reject Failure
 */
message EstimateTxSize {
	required uint32 outputs_count = 1;			// number of transaction outputs
	required uint32 inputs_count = 2;			// number of transaction inputs
	optional string coin_name = 3 [default='Bitcoin'];	// coin to use
}

/**
 * Estimated size of a transaction
 *
 * @validMode running
 * @sender device
 * @messageType response
 * @prev EstimateTxSize
 */
message TxSize {
	optional uint32 tx_size = 1;				// estimated size of transaction in bytes
}

/**
 * Sign transaction
 *
 * @validMode running
 * @sender host
 * @messageType request
 * @next PassphraseRequest
 * @next PinMatrixRequest
 * @resolve TxRequest
 * @reject Failure
 */
message SignTx {
	required uint32 outputs_count = 1;			// number of transaction outputs
	required uint32 inputs_count = 2;			// number of transaction inputs
	optional string coin_name = 3 [default='Bitcoin'];	// coin to use
}

/**
 * Simplified sign transaction
 * This method doesn't support streaming, so there are hardware limits in number of inputs and outputs.
 * In case of success, the result is returned using TxRequest message.
 *
 * @deprecated
 * @validMode running
 * @sender host
 * @messageType request
 * @next PassphraseRequest
 * @next PinMatrixRequest
 * @resolve TxRequest
 * @reject Failure
 */
message SimpleSignTx {
	repeated TxInputType inputs = 1;			// transaction inputs
	repeated TxOutputType outputs = 2;			// transaction outputs
	repeated TransactionType transactions = 3;		// transactions whose outputs are used to build current inputs
	optional string coin_name = 4 [default='Bitcoin'];	// coin to use
}

/**
 * Device asks for information for signing transaction or returns the last result
 * If request_index is set, device awaits TxAck message (with fields filled in according to request_type)
 * If signature_index is set, 'signature' contains signed input of signature_index's input
 *
 * @validMode running
 * @sender device
 * @messageType request
 * @prev SignTx
 * @prev SimpleSignTx
 * @prev TxAck
 */
message TxRequest {
	optional RequestType request_type = 1;			// what should be filled in TxAck message?
	optional TxRequestDetailsType details = 2;		// request for tx details
	optional TxRequestSerializedType serialized = 3;	// serialized data and request for next
}

/**
 * Provide transaction data
 *
 * @validMode running
 * @sender host
 * @messageType response
 * @prev TxRequest
 * @next TxRequest
 */
message TxAck {
	optional TransactionType tx = 1;
}

///////////////////////
// Identity messages //
///////////////////////

/**
 * Sign identity
 *
 * @validMode running
 * @sender host
 * @messageType request
 * @resolve SignedIdentity
 * @reject Failure
 */
message SignIdentity {
	optional IdentityType identity = 1;		// identity
	optional bytes challenge_hidden = 2;		// non-visible challenge
	optional string challenge_visual = 3;		// challenge shown on display (e.g. date+time)
	optional string ecdsa_curve_name = 4;		// ECDSA curve name to use
}

/**
 * Signed identity
 *
 * @validMode running
 * @sender device
 * @messageType response
 * @prev SignIdentity
 */
message SignedIdentity {
	optional string address = 1;			// identity address
	optional bytes public_key = 2;			// identity public key
	optional bytes signature = 3;			// signature of the identity data
}

/////////////////////////
// Bootloader messages //
/////////////////////////

/**
 * Erase firmware
 *
 * @validMode bootLoader
 * @sender host
 * @messageType request
 * @resolve Success
 * @reject Failure
 */
message FirmwareErase {
}

/**
 * Update firmware
 *
 * @validMode bootLoader
 * @sender host
 * @messageType request
 * @resolve Success
 * @reject Failure
 */
message FirmwareUpload {
	required bytes payload_hash = 1;	// sha256 hash of payload (meta + firmware)
	required bytes payload = 2;		// firmware to be loaded into device
}

/////////////////////////////////////////////////////////////
// Debug messages (only available if DebugLink is enabled) //
/////////////////////////////////////////////////////////////

/**
 * Debug request button
 *
 * @validMode debug
 * @sender host
 * @messageType request
 * @resolve Success
 */
message DebugLinkDecision {
	required bool yes_no = 1;			// true for "Confirm", false for "Cancel"
}

/**
 * Get device state
 *
 * @validMode debug
 * @sender host
 * @messageType request
 * @resolve DebugLinkState
 */
message DebugLinkGetState {
}

/**
 * Device current state
 *
 * @validMode debug
 * @sender device
 * @messageType response
 * @prev DebugLinkGetState
 */
message DebugLinkState {
	optional bytes layout = 1;				// raw buffer of display
	optional string pin = 2;				// current PIN, blank if PIN is not set/enabled
	optional string matrix = 3;				// current PIN matrix
	optional string mnemonic = 4;				// current BIP-39 mnemonic
	optional HDNodeType node = 5;				// current BIP-32 node
	optional bool passphrase_protection = 6;		// is node/mnemonic encrypted using passphrase?
	optional string reset_word = 7;				// word on device display during ResetDevice workflow
	optional bytes reset_entropy = 8;			// current entropy during ResetDevice workflow
	optional string recovery_fake_word = 9;			// (fake) word on display during RecoveryDevice workflow
	optional uint32 recovery_word_pos = 10;			// index of mnemonic word the device is expecting during RecoveryDevice workflow
	optional string recovery_cipher = 11;			// current recovery cipher
	optional string recovery_auto_completed_word = 12;	// last auto completed recovery word
	optional bytes firmware_hash = 13;			// hash of the application and meta header
	optional bytes storage_hash = 14;			// hash of storage
}

/**
 * Restart device
 *
 * @validMode debug
 * @sender host
 * @messageType request
 */
message DebugLinkStop {
}

/**
 * Log event on host
 *
 * @validMode debug
 * @sender device
 * @messageType request
 */
message DebugLinkLog {
	optional uint32 level = 1;
	optional string bucket = 2;
	optional string text = 3;
}

/**
 * Request: Ask device to fill config area with sample data (used for testing firmware upload)
 */
message DebugLinkFillConfig {
}
